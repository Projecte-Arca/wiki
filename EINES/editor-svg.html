---
---
<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Editor SVG Online Avan√ßat</title>
  <style>
    body { display: flex; flex-direction: column; align-items: center; font-family: Arial, sans-serif; margin: 0; padding: 1rem; }
    #toolbar { display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; }
    #toolbar button, #toolbar input[type=range], label.file-btn {
      background: #f0f0f0; border: none; padding: 1rem; border-radius: 6px; cursor: pointer; font-size: 1.2rem;
    }
    #toolbar button.active { background: #007bff; color: white; }
    #toolbar button:disabled { opacity: 0.5; cursor: not-allowed; }
    #container { display: flex; width: 100%; max-width: 1200px; gap: 1rem; }
    #editor, #preview { flex: 1; height: 80vh; border: 2px solid #ccc; border-radius: 8px; padding: 0.5rem; box-sizing: border-box; position: relative; overflow: hidden; background: #fff; }
    textarea { width: 100%; height: 100%; resize: none; font-family: monospace; font-size: 1rem; border: none; outline: none; }
    label.file-btn { background: #28a745; color: white; font-size: 1.2rem; }
    #preview svg { transform-origin: 0 0; }
  </style>
</head>
<body>
  <h1>Editor SVG Online Avan√ßat</h1>
  <div id="toolbar">
    <button id="undoBtn" title="Desfer">‚Ü∫</button>
    <button id="redoBtn" title="Refer">‚Üª</button>
    <button id="tool-pen" title="Dibuix lliure">‚óè</button>
    <button id="tool-erase" title="Goma square">üßΩ</button>
    <button id="tool-fill" title="Omplir">ü™£</button>
    <button id="tool-rect" title="Rectangle">‚ñ≠</button>
    <button id="tool-circle" title="Cercle">‚óØ</button>
    <button id="tool-line" title="L√≠nia">‚îÄ</button>
    <input type="range" id="strokeWidth" min="5" max="50" value="20" title="Amplada goma/tra√ß">
    <button id="toggleGrid" title="Activa/desactiva graella">#</button>
    <input type="range" id="zoom" min="0.5" max="4" step="0.1" value="1" title="Zoom">
    <button id="clearAll" title="Neteja tot">üóëÔ∏è</button>
    <button id="downloadBtn" title="Descarrega SVG">üíæ</button>
    <label for="fileInput" class="file-btn" title="Carrega SVG">üìÇ</label>
    <input type="file" id="fileInput" accept="image/svg+xml">
  </div>
  <div id="container">
    <div id="editor">
      <textarea id="svgEditor">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;
  &lt;defs&gt;&lt;/defs&gt;
&lt;/svg&gt;</textarea>
    </div>
    <div id="preview"></div>
  </div>

  <script>
    const editor = document.getElementById('svgEditor');
    const preview = document.getElementById('preview');
    const fileInput = document.getElementById('fileInput');
    const downloadBtn = document.getElementById('downloadBtn');
    const strokeWidthInput = document.getElementById('strokeWidth');
    const zoomInput = document.getElementById('zoom');
    const toggleGridBtn = document.getElementById('toggleGrid');
    const clearAllBtn = document.getElementById('clearAll');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');

    let currentTool = 'pen';
    let svgEl, drawing=false, startX=0, startY=0, currentEl=null, pathData='', isPanning=false;
    let gridOn = false;
    let eraseBox=null;
    let panX=0, panY=0;

    // History
    let history = [];
    let historyIndex = -1;
    function pushHistory() {
      if (historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
      history.push(svgEl.outerHTML);
      if (history.length > 10) history.shift(); else historyIndex++;
      updateHistoryButtons();
    }
    function updateHistoryButtons() {
      undoBtn.disabled = historyIndex <= 0;
      redoBtn.disabled = historyIndex >= history.length - 1;
    }
    undoBtn.addEventListener('click', () => {
      if (historyIndex > 0) {
        historyIndex--;
        loadFromHistory();
      }
    });
    redoBtn.addEventListener('click', () => {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        loadFromHistory();
      }
    });
    function loadFromHistory() {
      preview.innerHTML = history[historyIndex];
      svgEl = preview.querySelector('svg');
      editor.value = svgEl.outerHTML;
      initDraw(); applyGrid(); applyTransform(); updateHistoryButtons();
    }

    // Tool selection
    document.querySelectorAll('#toolbar button').forEach(btn=>{
      if (btn.id.startsWith('tool-')) btn.addEventListener('click', ()=>{
        document.querySelectorAll('#toolbar button').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active'); currentTool = btn.id.replace('tool-','');
      });
    });
    document.getElementById('tool-pen').click();

    function ensureSVG(code) {
      if (!code.includes('<svg')) return `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"800\" height=\"600\"><defs></defs></svg>`;
      return code;
    }

    function loadSVG(code) {
      code = ensureSVG(code);
      preview.innerHTML = code;
      svgEl = preview.querySelector('svg');
      initDraw(); applyGrid(); applyTransform();
      pushHistory();
      editor.value = svgEl.outerHTML;
    }

    function initDraw() {
      svgEl.replaceWith(svgEl.cloneNode(true));
      svgEl = preview.querySelector('svg');
      svgEl.style.cursor = 'crosshair';
      ['mousedown','mousemove','mouseup','wheel'].forEach(evt=>svgEl.addEventListener(evt, window['on'+evt.charAt(0).toUpperCase()+evt.slice(1)]));
    }

    function getPoint(e) {
      return {
        x: (e.offsetX - panX) / parseFloat(zoomInput.value),
        y: (e.offsetY - panY) / parseFloat(zoomInput.value),
        button: e.button
      };
    }

    function onMousedown(e) {
      const {button, x, y} = getPoint(e);
      if (button === 1) { isPanning = true; startX = e.clientX; startY = e.clientY; return; }
      if (button !== 0) return;
      drawing = true; currentEl = null;
      const sw = parseInt(strokeWidthInput.value, 10);
      switch (currentTool) {
        case 'rect': createShape('rect', x, y); break;
        case 'circle': createShape('circle', x, y); break;
        case 'line': createShape('line', x, y, e.ctrlKey); break;
        case 'pen': createPath(x, y); break;
        case 'erase': startEraseBox(x, y, sw); break;
        case 'fill': applyFill(x, y); drawing = false; pushHistory(); return;
      }
      editor.value = svgEl.outerHTML;
    }

    function onMousemove(e) {
      if (isPanning) {
        panX += e.clientX - startX;
        panY += e.clientY - startY;
        startX = e.clientX;
        startY = e.clientY;
        applyTransform();
        return;
      }
      if (!drawing) return;
      const {x, y} = getPoint(e);
      switch (currentTool) {
        case 'rect': updateRect(x, y); break;
        case 'circle': updateCircle(x, y); break;
        case 'line': updateLine(x, y, e.ctrlKey); break;
        case 'pen': updatePath(x, y); break;
        case 'erase': updateEraseBox(x, y); break;
      }
      editor.value = svgEl.outerHTML;
    }

    function onMouseup(e) {
      const {button} = getPoint(e);
      if (button === 1) { isPanning = false; return; }
      if (button !== 0) return;
      if (currentTool === 'erase') finishErase();
      drawing = false;
      currentEl = null;
      pushHistory();
    }

    function onWheel(e) {
      e.preventDefault();
      if (e.ctrlKey) return;
      const delta = -e.deltaY / 500;
      const newZoom = Math.min(4, Math.max(0.5, parseFloat(zoomInput.value) + delta));
      zoomInput.value = newZoom;
      applyTransform();
    }

    // Shape tools
    function createShape(type, x, y) {
      currentEl = document.createElementNS(svgEl.namespaceURI, type);
      if (type === 'rect') { currentEl.setAttribute('x', x); currentEl.setAttribute('y', y); }
      if (type === 'circle') { currentEl.setAttribute('cx', x); currentEl.setAttribute('cy', y); }
      if (type === 'line') {
        currentEl.setAttribute('x1', x);
        currentEl.setAttribute('y1', y);
        currentEl.setAttribute('x2', x);
        currentEl.setAttribute('y2', y);
      }
      setShapeStyle(currentEl);
      svgEl.appendChild(currentEl);
    }
    function updateRect(x, y) {
      const ox = parseFloat(currentEl.getAttribute('x'));
      const oy = parseFloat(currentEl.getAttribute('y'));
      const w = x - ox;
      const h = y - oy;
      currentEl.setAttribute('width', Math.abs(w));
      currentEl.setAttribute('height', Math.abs(h));
      if (w < 0) currentEl.setAttribute('x', x);
      if (h < 0) currentEl.setAttribute('y', y);
    }
    function updateCircle(x, y) {
      const cx = parseFloat(currentEl.getAttribute('cx'));
      const cy = parseFloat(currentEl.getAttribute('cy'));
      currentEl.setAttribute('r', Math.hypot(x - cx, y - cy));
    }
    function updateLine(x, y, ctrl) {
      let x2 = x;
      let y2 = y;
      if (ctrl) {
        const dx = x2 - parseFloat(currentEl.getAttribute('x1'));
        const dy = y2 - parseFloat(currentEl.getAttribute('y1'));
        if (Math.abs(dx) > Math.abs(dy)) y2 = currentEl.getAttribute('y1'); else x2 = currentEl.getAttribute('x1');
      }
      currentEl.setAttribute('x2', x2);
      currentEl.setAttribute('y2', y2);
    }
    function setShapeStyle(el) {
      el.setAttribute('stroke', 'black');
      el.setAttribute('stroke-width', 2);
      if (el.tagName !== 'line') el.setAttribute('fill', 'none');
      el.setAttribute('pointer-events', 'all');
    }

    // Freehand draw
    function createPath(x, y) {
      currentEl = document.createElementNS(svgEl.namespaceURI, 'path');
      pathData = `M${x},${y}`;
      currentEl.setAttribute('d', pathData);
      currentEl.setAttribute('stroke', 'black');
      currentEl.setAttribute('stroke-width', 2);
      currentEl.setAttribute('fill', 'none');
      currentEl.setAttribute('pointer-events', 'all');
      svgEl.appendChild(currentEl);
    }
    function updatePath(x, y) {
      pathData += ` L${x},${y}`;
      currentEl.setAttribute('d', pathData);
    }

    // Erase square tool
    function startEraseBox(x, y, size) {
      eraseBox = document.createElementNS(svgEl.namespaceURI, 'rect');
      eraseBox.setAttribute('width', size);
      eraseBox.setAttribute('height', size);
      eraseBox.setAttribute('x', x - size / 2);
      eraseBox.setAttribute('y', y - size / 2);
      eraseBox.setAttribute('fill', 'rgba(255,255,255,0.5)');
      eraseBox.setAttribute('stroke', 'red');
      eraseBox.setAttribute('stroke-width', 1);
      svgEl.appendChild(eraseBox);
    }
    function updateEraseBox(x, y) {
      const size = parseInt(strokeWidthInput.value, 10);
      eraseBox.setAttribute('x', x - size / 2);
      eraseBox.setAttribute('y', y - size / 2);
    }
    function finishErase() {
      const x = parseFloat(eraseBox.getAttribute('x'));
      const y = parseFloat(eraseBox.getAttribute('y'));
      const w = parseFloat(eraseBox.getAttribute('width'));
      const h = parseFloat(eraseBox.getAttribute('height'));
      eraseBox.remove();
      svgEl.querySelectorAll('rect:not(#gridRect), circle, line, path').forEach(el => {
        const bb = el.getBBox();
        if (bb.x >= x && bb.y >= y && bb.x + bb.width <= x + w && bb.y + bb.height <= y + h) el.remove();
      });
      eraseBox = null;
      editor.value = svgEl.outerHTML;
      pushHistory();
    }

    // Fill tool
    function applyFill(px, py) {
      const rect = svgEl.createSVGRect();
      rect.x = px;
      rect.y = py;
      rect.width = 1;
      rect.height = 1;
      const hits = svgEl.getIntersectionList(rect, svgEl);
      if (hits.length) {
        const target = hits[hits.length - 1];
        if (/^(rect|circle|path|line)$/i.test(target.tagName)) {
          target.setAttribute('fill', 'black');
          editor.value = svgEl.outerHTML;
          pushHistory();
        }
      }
    }

    // Grid
    function applyGrid() {
      const existing = svgEl.querySelector('#gridRect');
      const size = 20;
      if (gridOn && !existing) {
        const defs = svgEl.querySelector('defs');
        const pat = document.createElementNS(svgEl.namespaceURI, 'pattern');
        pat.setAttribute('id', 'gridPattern');
        pat.setAttribute('width', size);
        pat.setAttribute('height', size);
        pat.setAttribute('patternUnits', 'userSpaceOnUse');
        const path = document.createElementNS(svgEl.namespaceURI, 'path');
        path.setAttribute('d', `M${size} 0 L0 0 0 ${size}`);
        path.setAttribute('stroke', '#ccc');
        path.setAttribute('stroke-width', '0.5');
        path.setAttribute('fill', 'none');
        pat.appendChild(path);
        defs.appendChild(pat);
        const grd = document.createElementNS(svgEl.namespaceURI, 'rect');
        grd.setAttribute('id', 'gridRect');
        grd.setAttribute('width', svgEl.getAttribute('width'));
        grd.setAttribute('height', svgEl.getAttribute('height'));
        grd.setAttribute('fill', 'url(#gridPattern)');
        svgEl.insertBefore(grd, svgEl.firstChild);
      } else if (!gridOn && existing) {
        existing.remove();
      }
    }
    toggleGridBtn.addEventListener('click', () => {
      gridOn = !gridOn;
      loadSVG(svgEl.outerHTML);
    });

    // Clear All
    clearAllBtn.addEventListener('click', () => {
      svgEl.innerHTML = `<defs></defs>`;
      if (gridOn) applyGrid();
      editor.value = svgEl.outerHTML;
      pushHistory();
    });

    // Transform
    function applyTransform() {
      svgEl.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomInput.value})`;
    }
    zoomInput.addEventListener('input', applyTransform);

    // Download & Load
    downloadBtn.addEventListener('click', () => {
      const blob = new Blob([svgEl.outerHTML], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'disseny.svg'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    });
    fileInput.addEventListener('change', e => {
      const f = e.target.files[0]; if (!f) return;
      const r = new FileReader();
      r.onload = () => { editor.value = r.result; loadSVG(r.result); };
      r.readAsText(f);
    });

    // Inicial
    loadSVG(editor.value);
  </script>
</body>
</html>

