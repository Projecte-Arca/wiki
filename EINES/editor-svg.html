<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Editor SVG Pro (Fase 1: Eines Avançades)</title>
  <style>
    :root { --main-blue: #007bff; --light-gray: #f0f0f0; --dark-gray: #5a5a5a; --danger-red: #dc3545; }
    html, body { height: 100%; margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
    body { display: flex; flex-direction: column; background-color: #f4f4f8; }
    h1 { text-align: center; margin: 0.5rem 0; font-size: 1.5rem; color: #333; }
    #toolbar { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.5rem; padding: 0.5rem; background: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    .tool-group { display: flex; align-items: center; gap: 0.5rem; padding: 0.25rem 0.5rem; border: 1px solid #ddd; border-radius: 8px; }
    #toolbar button { background: var(--light-gray); border: 1px solid transparent; padding: 0.5rem; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; width: 44px; height: 44px; }
    #toolbar button svg { width: 24px; height: 24px; fill: var(--dark-gray); pointer-events: none; }
    #toolbar button.active { background: var(--main-blue); border-color: #0056b3; }
    #toolbar button.active svg { fill: white; }
    #toolbar button:disabled { opacity: 0.4; cursor: not-allowed; }
    
    #main-content { display: flex; flex: 1; width: 100%; gap: 1rem; padding: 1rem; box-sizing: border-box; min-height: 0; }
    #editor-container, #preview-container, #objects-list-container { flex: 1; min-width: 0; display: flex; flex-direction: column; border: 1px solid #ccc; border-radius: 8px; background: #fff; overflow: hidden; }
    #objects-list-container { flex: 0 0 200px; }
    .panel-header { font-size: 1rem; text-align: center; padding: 0.5rem; margin: 0; background: #eee; border-bottom: 1px solid #ccc; font-weight: bold; }
    #editor, #preview { flex-grow: 1; position: relative; overflow: auto; }
    #objects-list { margin: 0; padding: 0; list-style-type: none; }
    #objects-list li { padding: 0.5rem; border-bottom: 1px solid #eee; cursor: pointer; }
    #objects-list li:hover { background-color: #f0f0f0; }
    #objects-list li.selected { background-color: var(--main-blue); color: white; }
    
    textarea { width: 100%; height: 100%; resize: none; font-family: monospace; font-size: 1rem; border: none; outline: none; background: #2b2b2b; color: #f0f0f0; padding: 0.5rem; box-sizing: border-box; }
    #preview-svg-wrapper { display: inline-block; }
    svg { transform-origin: 0 0; touch-action: none; display: block; }
    
    #transform-box { position: absolute; border: 1px solid var(--main-blue); pointer-events: none; display: none; }
    .handle { position: absolute; width: 10px; height: 10px; background-color: white; border: 1px solid var(--main-blue); pointer-events: all; }
    .handle.resize { border-radius: 50%; }
    .handle.rotate { top: -25px; left: calc(50% - 6px); cursor: alias; border-radius: 0; }
    .handle.nw { top: -6px; left: -6px; cursor: nwse-resize; } .handle.ne { top: -6px; right: -6px; cursor: nesw-resize; }
    .handle.sw { bottom: -6px; left: -6px; cursor: nesw-resize; } .handle.se { bottom: -6px; right: -6px; cursor: nwse-resize; }

    #selection-box { position: absolute; background: rgba(0, 123, 255, 0.2); border: 1px solid var(--main-blue); pointer-events: none; z-index: 100; }
  </style>
</head>
<body>
  <h1>Editor SVG Pro (Fase 1)</h1>
  <div id="toolbar"><!-- Toolbar content from previous step --></div>
  <div id="main-content">
    <div id="editor-container"><h2 class="panel-header">Codi SVG</h2><div id="editor"><textarea id="svgEditor" spellcheck="false"></textarea></div></div>
    <div id="preview-container"><h2 class="panel-header">Vista Prèvia</h2><div id="preview"><div id="transform-box"><div class="handle rotate"></div><div class="handle resize nw"></div><div class="handle resize ne"></div><div class="handle resize sw"></div><div class="handle resize se"></div></div></div></div>
    <div id="objects-list-container"><h2 class="panel-header">Objectes</h2><ol id="objects-list"></ol></div>
  </div>
  
  <script>
    // --- SETUP & STATE ---
    const get = id => document.getElementById(id);
    const editor = get('editor'), preview = get('preview'), transformBox = get('transform-box'), objectsList = get('objects-list');
    let svgEl, currentTool = 'tool-select', objectCounters = {};
    let isDrawing=false, isPanning=false, isMoving=false, isMarqueeSelecting=false, isTransforming=false;
    let startX=0, startY=0, panX=0, panY=0, zoom=1;
    let selectedElements=[], history=[], historyIndex=-1;
    let strokeColor='black', fillColor='transparent';
    let transformState = {};

    // --- INITIALIZATION ---
    function initialize() {
        // Populate toolbar (to keep HTML clean)
        get('toolbar').innerHTML = `
            <div class="tool-group"><button id="tool-select" title="Seleccionar (V)"><svg viewBox="0 0 24 24"><path d="M13.79,2.43L15.21,3.84L5.43,13.62L3.62,12.21L13.79,2.43M16,16.59L19.59,13L21,14.41L14.41,21L13,19.59L16,16.59M3,18.5L5.5,21H11.5L9.5,19H6.5L3,18.5Z" /></svg></button><button id="selectAllBtn" title="Seleccionar Tot (Ctrl+A)"><svg viewBox="0 0 24 24"><path d="M2,2H11V6H9V4H4V9H6V11H2V2M22,13H18V11H20V9H15V13H13V22H22V13M4,13V15H9V20H11V15H13V13H4Z"/></svg></button></div>
            <div class="tool-group"><button id="tool-pen" title="Ploma (P)"><svg viewBox="0 0 24 24"><path d="M14.06,9L15,9.94L5.92,19H5V18.08L14.06,9M17.66,3C17.41,3 17.15,3.1 16.96,3.29L15.13,5.12L18.88,8.87L20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18.17,3.09 17.92,3 17.66,3M14.06,6.19L3,17.25V21H6.75L17.81,9.94L14.06,6.19Z" /></svg></button><button id="tool-rect" title="Rectangle (R)"><svg viewBox="0 0 24 24"><path d="M4,6V18H20V6H4Z" /></svg></button><button id="tool-circle" title="Cercle (C)"><svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" /></svg></button><button id="tool-line" title="Línia (L)"><svg viewBox="0 0 24 24"><path d="M4,11H20V13H4V11Z" /></svg></button><button id="tool-fill" title="Pot de Pintura (F)"><svg viewBox="0 0 24 24"><path d="M17.74,12.03L19,10.77L14.77,6.54L13.5,7.81L14.92,9.23L12,12.14L9.12,9.26L7.7,10.68L10.59,13.57L4.22,20H6L12,14L17.74,12.03M21,2L17,6L18,7L22,3L21,2Z"/></svg></button></div>
            <div class="tool-group"><button id="deleteBtn" title="Eliminar (Supr)" disabled><svg viewBox="0 0 24 24" style="fill: var(--danger-red);"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19V4M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg></button><button id="sendToBackBtn" title="Enviar al Fons" disabled><svg viewBox="0 0 24 24"><path d="M2,16H10V14H2V16M2,12H12V10H2V12M2,8H12V6H2V8M14,14V4H4V2H14A2,2 0 0,1 16,4V14H14M22,8H18V4H20V2H18A2,2 0 0,0 16,4V8H14V10H16V14H18V10H20V14H22V12H20V8Z" /></svg></button><button id="bringToFrontBtn" title="Portar al Davant" disabled><svg viewBox="0 0 24 24"><path d="M2,6H12V8H2V6M2,10H10V12H2V10M2,14H10V16H2V14M16,2H4V4H16V2M22,6H14V8H22V6M20,10H14V12H20V10M20,14H14V16H20V14Z" /></svg></button></div>
            <div class="tool-group"><button id="undoBtn" title="Desfer (Ctrl+Z)" disabled><svg viewBox="0 0 24 24"><path d="M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z" /></svg></button><button id="redoBtn" title="Refer (Ctrl+Y)" disabled><svg viewBox="0 0 24 24"><path d="M18.4,10.6C16.55,9 14.15,8 11.5,8C6.85,8 2.92,11.03 1.53,15.22L3.9,16C4.95,12.81 7.96,10.5 11.5,10.5C13.46,10.5 15.23,11.22 16.62,12.38L13,16H22V7L18.4,10.6Z" /></svg></button></div>`;
        setupEventListeners();
        loadSVG('<svg xmlns="http://www.w3.org/2000/svg" id="canvas" width="800" height="600" style="background-color: white;"><defs></defs></svg>');
        selectTool('tool-select');
    }

    function setupEventListeners() {
        const listeners = { 'undoBtn': undo, 'redoBtn': redo, 'deleteBtn': deleteSelection, 'selectAllBtn': selectAllElements, 'bringToFrontBtn': () => layerSelected(true), 'sendToBackBtn': () => layerSelected(false) };
        Object.entries(listeners).forEach(([id, func]) => get(id).addEventListener('click', func));
        document.querySelectorAll('#toolbar button[id^="tool-"]').forEach(btn => btn.addEventListener('click', () => selectTool(btn.id)));
        
        ['mousedown', 'touchstart'].forEach(evt => preview.addEventListener(evt, handlePointerDown, { passive: false }));
        ['mousemove', 'touchmove'].forEach(evt => window.addEventListener(evt, handlePointerMove, { passive: false }));
        ['mouseup', 'touchend', 'touchcancel'].forEach(evt => window.addEventListener(evt, handlePointerUp, { passive: false }));
        preview.addEventListener('wheel', handleWheel, { passive: false });
        
        transformBox.querySelectorAll('.handle').forEach(handle => {
            handle.addEventListener('mousedown', e => handleTransformStart(e, handle.className));
            handle.addEventListener('touchstart', e => handleTransformStart(e, handle.className));
        });
        
        objectsList.addEventListener('click', e => {
            if (e.target.tagName === 'LI') {
                const el = svgEl.querySelector('#' + e.target.dataset.id);
                if (el) {
                    if (e.shiftKey) { toggleSelection(el); }
                    else { selectElement(el); }
                }
            }
        });
    }

    // --- POINTER & TRANSFORM HANDLERS ---
    function handlePointerDown(e) {
        if (e.target.classList.contains('handle')) return; // Deixa que ho gestioni el handleTransformStart
        const { x, y, originalEvent: oe } = getPoint(e);
        if (oe.button===1 || (oe.touches && oe.touches.length===2)) { isPanning=true; startX=oe.touches?oe.touches[0].clientX:oe.clientX; startY=oe.touches?oe.touches[0].clientY:oe.clientY; return; }
        startX = x; startY = y;
        const target = oe.target.closest('rect, circle, path, line');

        if (currentTool === 'tool-select') {
            if (target && isValidElement(target)) { isMoving = true; if (oe.shiftKey) { toggleSelection(target); } else if (!selectedElements.includes(target)) { selectElement(target); } }
            else { isMarqueeSelecting = true; const r = preview.getBoundingClientRect(); createSelectionBox(oe.clientX-r.left, oe.clientY-r.top); deselectAll(); }
        } else if (currentTool === 'tool-fill' && target && isValidElement(target)) {
            target.setAttribute('fill', fillColor); pushHistory();
        } else if (currentTool !== 'tool-select' && currentTool !== 'tool-fill') {
            isDrawing = true; if(currentTool==='tool-pen') createPath(x,y); else createShape(currentTool.replace('tool-',''), x,y);
        }
    }

    function handlePointerMove(e) {
        if (isPanning) { const c=e.touches?e.touches[0]:e; panX+=c.clientX-startX; panY+=c.clientY-startY; startX=c.clientX; startY=c.clientY; applyTransform(); return; }
        const { x, y, originalEvent: oe } = getPoint(e);
        if (isTransforming) { handleTransform(x, y, oe); }
        else if (isMoving && selectedElements.length>0) { moveSelected(x-startX, y-startY); startX=x; startY=y; }
        else if (isMarqueeSelecting) { const r=preview.getBoundingClientRect(); updateSelectionBox(oe.clientX-r.left, oe.clientY-r.top); }
        else if (isDrawing) { const u={'tool-rect':updateRect,'tool-circle':updateCircle,'tool-line':updateLine,'tool-pen':updatePath}; u[currentTool]?.(x,y,oe.ctrlKey); updateEditor(); }
    }
    
    function handlePointerUp() {
        if (isDrawing || isMoving || isTransforming) {
            if (isTransforming) applyTransformsToElements(); // Grava la transformació final a cada element
            pushHistory();
        }
        if (isMarqueeSelecting) selectInMarquee();
        isDrawing=isPanning=isMoving=isMarqueeSelecting=isTransforming=false;
        currentEl = null; removeSelectionBox();
    }
    
    // --- DRAWING & SHAPE CREATION ---
    function createShape(type, x, y) {
        objectCounters[type] = (objectCounters[type] || 0) + 1;
        const id = `${type}_${objectCounters[type]}`;
        currentEl = document.createElementNS('http://www.w3.org/2000/svg', type);
        currentEl.id = id;
        currentEl.setAttribute('stroke', strokeColor); currentEl.setAttribute('stroke-width', '2'); currentEl.setAttribute('fill', type === 'line' ? 'none' : fillColor);
        const attr = { rect: {x,y,width:0,height:0}, circle: {cx:x,cy:y,r:0}, line: {x1:x,y1:y,x2:x,y2:y} };
        Object.entries(attr[type]).forEach(([k,v]) => currentEl.setAttribute(k,v));
        svgEl.appendChild(currentEl);
    }
    function createPath(x,y) { objectCounters.path = (objectCounters.path || 0) + 1; const id = `path_${objectCounters.path}`; let pathData = `M${x},${y}`; currentEl = document.createElementNS('http://www.w3.org/2000/svg', 'path'); currentEl.id = id; currentEl.setAttribute('d', pathData); currentEl.setAttribute('stroke', strokeColor); currentEl.setAttribute('stroke-width', '2'); currentEl.setAttribute('fill', 'none'); svgEl.appendChild(currentEl); }
    const updateRect = (x,y) => { const w=x-startX, h=y-startY; currentEl.setAttribute('width',Math.abs(w)); currentEl.setAttribute('height',Math.abs(h)); if(w<0)currentEl.setAttribute('x',x); if(h<0)currentEl.setAttribute('y',y); };
    const updateCircle = (x,y) => currentEl.setAttribute('r', Math.hypot(x - startX, y - startY));
    const updateLine = (x,y,s) => { let x2=x, y2=y; if(s){if(Math.abs(x-startX)>Math.abs(y-startY))y2=startY;else x2=startX;} currentEl.setAttribute('x2',x2); currentEl.setAttribute('y2',y2); };
    const updatePath = (x,y) => { currentEl.setAttribute('d', currentEl.getAttribute('d') + ` L${x},${y}`); };

    // --- SELECTION & MANIPULATION ---
    function selectTool(toolId) { document.querySelector('#toolbar button.active')?.classList.remove('active'); get(toolId).classList.add('active'); currentTool = toolId; deselectAll(); }
    const isValidElement = el => el && el.id && el.ownerSVGElement;
    function deselectAll() { selectedElements.forEach(el => el.classList.remove('selected-indicator')); selectedElements = []; updateActionButtons(); drawTransformBox(); }
    function selectElement(el) { deselectAll(); selectedElements.push(el); el.classList.add('selected-indicator'); updateActionButtons(); drawTransformBox(); }
    function toggleSelection(el) { const i = selectedElements.indexOf(el); if(i > -1){ el.classList.remove('selected-indicator'); selectedElements.splice(i,1); } else { selectedElements.push(el); el.classList.add('selected-indicator'); } updateActionButtons(); drawTransformBox(); }
    function selectAllElements() { deselectAll(); svgEl.querySelectorAll('rect,circle,line,path').forEach(el => selectedElements.push(el)); selectedElements.forEach(el => el.classList.add('selected-indicator')); updateActionButtons(); drawTransformBox(); }
    function deleteSelection() { if (!selectedElements.length) return; selectedElements.forEach(el => el.remove()); deselectAll(); pushHistory(); }
    function moveSelected(dx, dy) { selectedElements.forEach(el => applyTransformToElement(el, { dx, dy })); updateEditor(); drawTransformBox(); }
    function layerSelected(toFront) { if (!selectedElements.length) return; selectedElements.forEach(el => { if (toFront) svgEl.appendChild(el); else svgEl.insertBefore(el, svgEl.querySelector('defs')?.nextSibling); }); pushHistory(); }
    
    // --- UI & UX ---
    function updateActionButtons() { const d = selectedElements.length === 0; get('deleteBtn').disabled = d; get('sendToBackBtn').disabled=d; get('bringToFrontBtn').disabled=d; updateObjectsList(); }
    function updateObjectsList() { objectsList.innerHTML = ''; svgEl.querySelectorAll('rect,circle,line,path').forEach(el => { const li = document.createElement('li'); li.textContent = el.id || el.tagName; li.dataset.id = el.id; if (selectedElements.includes(el)) li.classList.add('selected'); objectsList.appendChild(li); }); }

    // --- TRANSFORMATIONS ---
    function drawTransformBox() {
        if (selectedElements.length === 0) { transformBox.style.display = 'none'; return; }
        const collectiveBox = getCollectiveBBox(selectedElements);
        const svgRect = svgEl.getBoundingClientRect();
        const previewRect = preview.getBoundingClientRect();

        const x = (collectiveBox.x * zoom + panX + svgRect.left - previewRect.left);
        const y = (collectiveBox.y * zoom + panY + svgRect.top - previewRect.top);
        
        Object.assign(transformBox.style, {
            display: 'block', left: `${x}px`, top: `${y}px`,
            width: `${collectiveBox.width * zoom}px`, height: `${collectiveBox.height * zoom}px`,
            transform: `rotate(${collectiveBox.rotation}deg)`
        });
    }

    function handleTransformStart(e, handleClass) {
        e.stopPropagation(); isTransforming = true;
        const bbox = getCollectiveBBox(selectedElements);
        const center = { x: bbox.x + bbox.width / 2, y: bbox.y + bbox.height / 2 };
        const { x, y } = getPoint(e);
        transformState = {
            handle: handleClass, bbox: bbox, center: center, startX: x, startY: y,
            startAngle: Math.atan2(y - center.y, x - center.x),
            initialTransforms: selectedElements.map(el => parseTransform(el.getAttribute('transform')))
        };
    }
    
    function handleTransform(x, y, event) {
        const { handle, bbox, center, startX, startY, startAngle, initialTransforms } = transformState;
        if (handle.includes('rotate')) {
            const currentAngle = Math.atan2(y - center.y, x - center.x);
            const angle = (currentAngle - startAngle) * 180 / Math.PI;
            selectedElements.forEach((el, i) => applyTransformToElement(el, { rotation: angle }, initialTransforms[i]));
        } else {
            const dx = (x - startX) / bbox.width;
            const dy = (y - startY) / bbox.height;
            let sx = 1, sy = 1;
            if (handle.includes('e')) sx = 1 + dx; if (handle.includes('w')) sx = 1 - dx;
            if (handle.includes('s')) sy = 1 + dy; if (handle.includes('n')) sy = 1 - dy;
            if(event.shiftKey) { const avg = (sx + sy) / 2; sx = avg; sy = avg; }
            selectedElements.forEach((el, i) => applyTransformToElement(el, { scaleX: sx, scaleY: sy, cx: bbox.x, cy: bbox.y }, initialTransforms[i]));
        }
        drawTransformBox();
    }
    
    function applyTransformToElement(el, {dx=0, dy=0, scaleX=1, scaleY=1, rotation=0, cx=0, cy=0}, baseTransform) {
        let t = baseTransform || parseTransform(el.getAttribute('transform'));
        
        // This is a simplified matrix multiplication logic.
        // A full matrix library would be more robust but this covers the basics.
        const newT = `translate(${t.tx+dx}, ${t.ty+dy}) rotate(${t.angle+rotation}, ${t.cx || cx}, ${t.cy || cy}) scale(${t.sx*scaleX}, ${t.sy*scaleY})`;
        el.setAttribute('transform', newT);
    }
    
    function applyTransformsToElements() {
        // This function would "bake" the transform attribute into the shape's coordinates
        // For now, we'll leave it in the transform attribute as it's non-destructive.
    }
    
    // --- HISTORY & SVG MANAGEMENT ---
    function loadSVG(code) { try { const doc = new DOMParser().parseFromString(code,"image/svg+xml"); if(doc.querySelector('parsererror')) throw new Error('Invalid SVG'); svgEl = doc.documentElement; preview.innerHTML = ''; preview.prepend(transformBox); preview.append(svgEl); history = [svgEl.outerHTML]; historyIndex = 0; updateHistoryButtons(); applyTransform(); updateEditor(); deselectAll(); } catch(e) { console.error("Error al carregar SVG:", e); } }
    function pushHistory() { if (historyIndex < history.length - 1) history.splice(historyIndex + 1); history.push(svgEl.outerHTML); if (history.length > 50) history.shift(); historyIndex = history.length - 1; updateHistoryButtons(); updateEditor(); }
    function undo() { if (historyIndex > 0) loadFromHistory(--historyIndex); }
    function redo() { if (historyIndex < history.length - 1) loadFromHistory(++historyIndex); }
    function loadFromHistory(index) { const tempSVG = history[index]; deselectAll(); loadSVG(tempSVG); history[index] = tempSVG; updateHistoryButtons(); }
    
    // --- UTILITIES ---
    const getPoint = (e) => { if (!svgEl) return {x:0, y:0, originalEvent: e}; const r = svgEl.getBoundingClientRect(); const c = e.touches ? e.touches[0] || e.changedTouches[0] : e; return { x: (c.clientX - r.left) / zoom, y: (c.clientY - r.top) / zoom, originalEvent: e }; };
    function getCollectiveBBox(elements) { if (elements.length === 0) return { x: 0, y: 0, width: 0, height: 0, rotation: 0 }; let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity; elements.forEach(el => { const bbox = el.getBBox({ stroke: true, fill: true }); const t = parseTransform(el.getAttribute('transform')); const corners = [ {x:bbox.x, y:bbox.y}, {x:bbox.x+bbox.width, y:bbox.y}, {x:bbox.x, y:bbox.y+bbox.height}, {x:bbox.x+bbox.width, y:bbox.y+bbox.height} ]; corners.forEach(c => { const pt = new DOMPoint(c.x, c.y).matrixTransform(new DOMMatrix().translate(t.tx, t.ty)); minX=Math.min(minX,pt.x); minY=Math.min(minY,pt.y); maxX=Math.max(maxX,pt.x); maxY=Math.max(maxY,pt.y); }); }); return { x: minX, y: minY, width: maxX - minX, height: maxY - minY, rotation: elements.length===1 ? parseTransform(elements[0].getAttribute('transform')).angle : 0 }; }
    function parseTransform(str) { const t = { tx:0, ty:0, angle:0, sx:1, sy:1 }; if(!str) return t; (str.match(/(\w+\(.*?\))/g) || []).forEach(p => { const [type, val] = p.split('('); const v = val.slice(0, -1).split(/[, ]+/).map(parseFloat); if (type==='translate') { t.tx=v[0]; t.ty=v[1]||0; } if (type==='rotate') { t.angle=v[0]; t.cx=v[1]; t.cy=v[2]; } if (type==='scale') { t.sx=v[0]; t.sy=v[1]||v[0]; } }); return t; }
    function applyTransform() { if (svgEl) svgEl.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`; drawTransformBox(); }
    const updateEditor = () => { if (document.activeElement !== get('svgEditor') && svgEl) { get('svgEditor').value = svgEl.outerHTML; } };
    const updateHistoryButtons = () => { get('undoBtn').disabled = historyIndex <= 0; get('redoBtn').disabled = historyIndex >= history.length - 1; };
    // Dummy functions for now
    function createSelectionBox() {} function updateSelectionBox() {} function removeSelectionBox() {} function selectInMarquee() {} function toggleColor() {}
    
    // --- START ---
    initialize();
  </script>
</body>
</html>
